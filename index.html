<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Introduction to Databases by Anderson-Lab</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/main.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>

      <header>
        <h1>Introduction to Databases</h1>
        <p>Comparative Database Technologies</p>
      </header>

      <div id="banner">
        <span id="logo"></span>

        <a href="https://github.com/Anderson-Lab/introduction-to-databases" class="button fork"><strong>View On GitHub</strong></a>
        <div class="downloads">
          <span>Downloads:</span>
          <ul>
            <li><a href="https://github.com/Anderson-Lab/introduction-to-databases/zipball/master" class="button">ZIP</a></li>
            <li><a href="https://github.com/Anderson-Lab/introduction-to-databases/tarball/master" class="button">TAR</a></li>
          </ul>
        </div>
      </div><!-- end banner -->

    <div class="wrapper">
      <nav>
        <ul></ul>
      </nav>
      <section>
        <h1>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h1>

<p>It is often said that data is the new oil. If this is the case, then the database is how we store, collect, organize, and basically do everything with the oil until it goes into your car.</p>

<p>For a long time, relational databases were the only game in town. It is not the case anymore. There are now a variety of options, schemaless, horizontal scaling, high availability, etc. These are generally known as NoSQL databases. On this page, we will attempt to compare different databases, and more importantly try to answer the all important question:</p>

<p>What database or combination of databases best resolves your problem?</p>

<p>To answer this, we need to learn a little more.</p>

<p>What type of datastore is this?</p>

<ul>
<li>Relational (e.g., postgres)</li>
<li>Key-value (e.g., Riak, Redis)</li>
<li>Columnar (e.g., HBase)</li>
<li>Document-oriented (e.g., MongoDB, CouchDB)</li>
<li>Graph (e.g., Neo4J)</li>
</ul>

<p>Databases are created for a purpose. So we need to understand their purpose to pick.</p>

<p>How do you talk to it?</p>

<p>How does it perform?</p>

<p>How does it scale?</p>

<p>Important to remember: Most of your problems can be solved by multiple databases, so it is a matter of finding the best for the situation.</p>

<h3>
<a id="relational-databases" class="anchor" href="#relational-databases" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Relational Databases</h3>

<ul>
<li>Traditional</li>
<li>Relational Database Management Systems (RDBMSs) are set-theory-based.</li>
<li>Tables with rows and columns.</li>
<li>Write queries in Structured Query Language (SQL)</li>
<li>Data types are numeric, strings, dates, blobs, etc</li>
<li>Based on mathematical relational (set) theory</li>
</ul>

<h3>
<a id="key-value" class="anchor" href="#key-value" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Key-Value</h3>

<ul>
<li>Pairs keys to values in much the same way as a map (or hastable)</li>
<li>Very simple and great performance</li>
<li>No complex query and aggregation needs</li>
</ul>

<h3>
<a id="columnar" class="anchor" href="#columnar" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Columnar</h3>

<ul>
<li>Data from a given column (in the two-dimensional table sense) is stored together.</li>
<li>By contrast, a row-oriented database (like an RDBMS) keeps information about a row together.</li>
<li>Adding columns is quite inexpensive and is done on a row-by-row basis.</li>
<li>Each row can have a different set of columns, or none at all, allowing tables to remain sparse without incurring a storage cost for null values. </li>
<li>Columnar is about midway between relational and key-value. </li>
</ul>

<h3>
<a id="document-oriented-databases-store-well-documents" class="anchor" href="#document-oriented-databases-store-well-documents" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Document-oriented databases store, well, documents</h3>

<ul>
<li>A document is like a hash</li>
<li>Documents can contain nested structures</li>
<li>Exhibit a high degree of flexibility, allowing for variable domains. </li>
</ul>

<h3>
<a id="graph-databases" class="anchor" href="#graph-databases" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Graph Databases</h3>

<ul>
<li>Less commonly used database styles</li>
<li>Good at dealing with highly interconnected data. </li>
<li>A graph database consists of nodes and relationships between nodes. </li>
<li>Strength of graph databases is traversing through the nodes by following relationships. </li>
</ul>

<h1>
<a id="postgresql" class="anchor" href="#postgresql" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>PostgreSQL</h1>

<ul>
<li>Common</li>
<li>Old and trusty tool</li>
<li>Solves a number of problems</li>
<li>We can't move on to fancy new databases until we understand this</li>
<li>Battle-tested</li>
<li>It’s fast and reliable</li>
<li>Can handle terabytes of data</li>
<li>Has been proven to run in high-profile production</li>
<li>Companies using it: Skype, France’s Caisse Nationale d’Allocations Familiales (CNAF), and the United States’ Federal Aviation Administration (FAA). </li>
</ul>

<h3>
<a id="getting-started" class="anchor" href="#getting-started" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Getting Started</h3>

<p>Create the book schema</p>

<pre><code>$ createdb book
</code></pre>

<p>Run your first query</p>

<pre><code>psql book -c "SELECT '1'::cube;" 
</code></pre>

<h3>
<a id="relations-crud-and-joins" class="anchor" href="#relations-crud-and-joins" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Relations, CRUD, and Joins</h3>

<p>Postgres provides a back-end server that does all of the work and a command-line shell to connect to the running. It's a good thing we are good at this!</p>

<p>Connect to the database and the schema book</p>

<pre><code>psql book
</code></pre>

<ul>
<li>Typing \h lists information about SQL commands</li>
<li>Follows the SQL convention of calling relations TABLEs</li>
<li>Attributes are COLUMNs</li>
<li>Tuples are ROWs.</li>
<li>You may encounter the mathematical terms relations, attributes, and tuples. </li>
</ul>

<p>PostgreSQL is a design-first datastore. Design the schema first. Then enter data. Here is how you create a table:</p>

<pre><code>CREATE TABLE countries ( country_code char(2) PRIMARY KEY, country_name text UNIQUE );
</code></pre>

<p>See mathematical relations in book for foundations of relational database</p>

<p>Once we have a table, we can insert it into it</p>

<pre><code>INSERT INTO countries (country_code, country_name) 
VALUES ('us','United States'), ('mx','Mexico'), ('au','Australia'), ('gb','United Kingdom'), ('de','Germany'), ('ll','Loompaland'); 
</code></pre>

<p>What if you try to insert a duplicate?</p>

<pre><code>INSERT INTO countries VALUES ('uk','United Kingdom');
ERROR: duplicate key value violates unique constraint "countries_country_name_key" DETAIL: Key (country_name)=(United Kingdom) already exists.
</code></pre>

<p>How can we get data back out?</p>

<pre><code>SELECT * FROM countries;
country_code | country_name 
--------------+--------------
us | United States 
mx | Mexico 
au | Australia 
gb | United Kingdom 
de | Germany 
ll | Loompaland 
(6 rows)
</code></pre>

<p>How to remove from the database?</p>

<pre><code>DELETE FROM countries WHERE country_code = 'll'; 
</code></pre>

<p>CRUD: Create, Read, Update, and Delete.</p>

<ul>
<li>Inserting new records (creating)</li>
<li>Reading existing records (reading)</li>
<li>Modifying existing records (updating)</li>
<li>Removing records you no longer need (deleting)</li>
</ul>

<p>It gets more complex</p>

<pre><code>CREATE TABLE cities ( 
  name text NOT NULL, 
  postal_code varchar(9) CHECK (postal_code &lt;&gt; ''), 
  country_code char(2) REFERENCES countries, 
  PRIMARY KEY (country_code, postal_code) ); 
</code></pre>

<ul>
<li>Constrained the name in cities by disallowing NULL values. </li>
<li>Constrained postal_code by checking that no values are empty strings (&lt;&gt; means not equal). </li>
<li>PRIMARYKEY uniquely identifies a row - created a compound key: country_code + postal_code.</li>
</ul>

<p><b>Foreign keys and referential integrity</b></p>

<pre><code>INSERT INTO cities VALUES ('Toronto','M4C1B5','ca');
ERROR: insert or update on table "cities" violates foreign key constraint "cities_country_code_fkey" DETAIL: Key (country_code)=(ca) is not present in table "countries".
</code></pre>

<ul>
<li>country_code REFERENCES countries</li>
<li>the country_code must exist in the countries table. </li>
<li>Called maintaining referential integrity.</li>
</ul>

<p>See Figure 1.</p>

<h3>
<a id="join-reads" class="anchor" href="#join-reads" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Join Reads</h3>

<ul>
<li>Most other databases also perform CRUD operations.</li>
<li>What sets relational databases like PostgreSQL apart is their ability to join tables together when reading them. </li>
<li>Joining is an operation taking two separate tables and combining them in some way to return a single table. </li>
<li>In the simplest form, you specify two columns (one from each table) to match by, using the ON keyword. </li>
</ul>

<pre><code>SELECT cities.*, country_name FROM cities INNER JOIN countries ON cities.country_code = countries.country_code;
country_code | name | postal_code | country_name 
--------------+----------+-------------+--------------
us | Portland | 97205 | United States 
</code></pre>

<p>Outer joins</p>

<ul>
<li>Merging two tables when the results of one table must always be returned, whether or not any matching column values exist on the other table. </li>
</ul>

<pre><code>SELECT e.title, v.name FROM events e LEFT JOIN venues v ON e.venue_id = v.venue_id;
</code></pre>

<p>Example of left join:</p>

<pre><code>SELECT e.title, v.name
FROM events e LEFT JOIN venues v
ON e.venue_id = v.venue_id;
title            | name
-----------------+----------------
LARP Club        | Voodoo Donuts
April Fools Day  |
Christmas Day    |
</code></pre>

<h3>
<a id="erd" class="anchor" href="#erd" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ERD</h3>

<p>See sample ERD in Figure 2</p>

<h3>
<a id="indexes-and-b-trees" class="anchor" href="#indexes-and-b-trees" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Indexes and B-trees</h3>

<p>Consider the statement:</p>

<pre><code>SELECT * FROM events WHERE event_id = 2;
</code></pre>

<p>How many records does PostgreSQL have to look through?</p>

<p>An index is a special data structure built to avoid a full table scan when performing a query. Without an index you have to check every row for a match. For indices, we use a B-tree data structure. See Figure 3.</p>

<p>Here is a good summary of concepts. <b>Term Definition</b></p>

<ul>
<li>Column - A domain of values of a certain type, sometimes called an attribute</li>
<li>Row - An object comprised as a set of column values, sometimes called
a tuple</li>
<li>Table A set of rows with the same columns, sometimes called a relation</li>
<li>Primary key - The unique value that pinpoints a specific row</li>
<li>CRUD - Create, Read, Update, Delete</li>
<li>SQL - Structured Query Language, the lingua franca of a relational database</li>
<li>Join Combining two tables into one by some matching columns</li>
<li>Left join - Combining two tables into one by some matching columns or NULL if nothing matches the left table </li>
<li>Index - A data structure to optimize selection of a specific set of columns</li>
<li>B-tree - A good standard index; values are stored as a balanced tree
data structure; very flexible</li>
</ul>

<h4>
<a id="aggregate-functions" class="anchor" href="#aggregate-functions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Aggregate Functions</h4>

<pre><code>title            | starts              |           ends      | venue
-----------------+---------------------+---------------------+---------------
Wedding          | 2012-02-26 21:00:00 | 2012-02-26 23:00:00 | Voodoo Donuts
Dinner with Mom  | 2012-02-26 18:00:00 | 2012-02-26 20:30:00 | My Place
Valentine’s Day  | 2012-02-14 00:00:00 | 2012-02-14 23:59:00 |
</code></pre>

<p>Consider the following statements, where % is a wildcard:</p>

<pre><code>SELECT count(title)
FROM events
WHERE title LIKE '%Day%';
</code></pre>

<pre><code>SELECT min(starts), max(ends)
FROM events INNER JOIN venues
ON events.venue_id = venues.venue_id
WHERE venues.name = 'Crystal Ballroom';
</code></pre>

<p>These are great, but limited on their own. Consider what if we wanted to count by vendor ID:</p>

<pre><code>SELECT count(*) FROM events WHERE venue_id = 1;
SELECT count(*) FROM events WHERE venue_id = 2;
SELECT count(*) FROM events WHERE venue_id = 3;
SELECT count(*) FROM events WHERE venue_id IS NULL;
</code></pre>

<p>This is pretty annoying. What we really need is a group by statement!</p>

<pre><code>SELECT venue_id FROM events GROUP BY venue_id;
</code></pre>

<h1>
<a id="riak" class="anchor" href="#riak" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Riak</h1>

<ul>
<li>Pronounced "Ree-ahck"</li>
<li>Distributed key-value database</li>
<li>Values can be anything - plain text, json, XML, images, video clips</li>
<li>Accessible through simple HTTP interface</li>
<li>Fault-tolerant - servers may go up or down at any moment - no need to worry about your cluster</li>
<li>There are some downsides - no robust support for ad hoc queries, key-value stores, no foreign keys</li>
</ul>

<h3>
<a id="riak-and-the-web" class="anchor" href="#riak-and-the-web" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Riak and the Web</h3>

<ul>
<li>Query via URLs, headers, verbs, and Riak returns in standard HTTP response codes</li>
<li>Easy to setup, easy to manage, can grow with your needs</li>
<li>Ever used SimpleDB or S3 from Amazon? There are a lot of similarities because Riak is inspired by Amazon's Dynamo paper.</li>
</ul>

<h3>
<a id="rest" class="anchor" href="#rest" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>REST</h3>

<ul>
<li>REpresentational State Transfer</li>
<li>
<i>de facto</i> architecture of web applications</li>
<li>REST is a guideline for mapping resources to URLs and interacting with them using CRUD verbs: POST (Create), GET (Read), PUT (Update), and DELETE (Delete).</li>
<li>We are going to use the good old curl command to speak directly to Riak's server.</li>
</ul>

<h3>
<a id="put" class="anchor" href="#put" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>PUT</h3>

<p>PUT parameter tells cURL that we want to perform an HTTP PUT action to store and retrieve on an explicit key.</p>

<pre><code>curl -v -X PUT http://localhost:8098/riak/favs/db \
-H "Content-Type: text/html" \
-d "&lt;html&gt;&lt;body&gt;&lt;h1&gt;My new favorite DB is RIAK&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"
</code></pre>

<p>Parameters:</p>

<ul>
<li>-H attribute sets the following text as HTTP header information</li>
<li>-d is the value</li>
<li>-X PUT is what tells cURL we are using the PUT operation.</li>
</ul>

<h3>
<a id="buckets" class="anchor" href="#buckets" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Buckets</h3>

<p>Riak is key-value. It breaks up keys into buckets to avoid key collisions. For example, the key java for the language and the drink java.</p>

<p>Let's create a bucket</p>

<pre><code>http://SERVER:PORT/riak/BUCKET/KEY
</code></pre>

<p>You don't need to explicitly create a bucket. All you need to do is execute a PUT.</p>

<pre><code>curl -v -X PUT http://localhost:8098/riak/animals/ace \
-H "Content-Type: application/json" \
-d '{"nickname" : "The Wonder Dog", "breed" : "German Shepherd"}'
</code></pre>

<p>We can list the buckets that we've got using:</p>

<pre><code>curl -X GET http://localhost:8098/riak?buckets=true
</code></pre>

<p>If you aren't picky about keys, you can get Riak to autocreate.</p>

<h3>
<a id="get-to-retrieve-a-key" class="anchor" href="#get-to-retrieve-a-key" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GET to retrieve a key</h3>

<pre><code>curl http://localhost:8098/riak/animals/6VZc2o7zKxq2B34kJrm1S0ma3PO
</code></pre>

<h3>
<a id="delete-is-also-easy" class="anchor" href="#delete-is-also-easy" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DELETE is also easy</h3>

<pre><code>curl -i -X DELETE http://localhost:8098/riak/animals/6VZc2o7zKxq2B34kJrm1S0ma3PO
</code></pre>

<h3>
<a id="forgotten-your-keys" class="anchor" href="#forgotten-your-keys" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Forgotten your keys</h3>

<pre><code>curl http://localhost:8098/riak/animals?keys=true
</code></pre>

<h3>
<a id="links" class="anchor" href="#links" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Links</h3>

<p>Links are metadata that associate one key to other keys. Here is the basic structure.</p>

<pre><code>Link: &lt;/riak/bucket/key&gt;; riaktag=\"whatever\"
</code></pre>

<p>The key that we are linking to is in the pointy brackets. Then the tag relates to this value and we can set it to anything.</p>

<p>Links are one directional. So if want to set the fact that Cage 1 contains the dog polly and it is installing in room 101.</p>

<pre><code>curl -X PUT http://localhost:8098/riak/cages/1 \
-H "Content-Type: application/json" \
-H "Link: &lt;/riak/animals/polly&gt;; riaktag=\"contains\"" \
-d '{"room" : 101}'
</code></pre>

<p>You can also do multiple links.</p>

<pre><code>$ curl -X PUT http://localhost:8098/riak/cages/2 \
-H "Content-Type: application/json" \
-H "Link:&lt;/riak/animals/ace&gt;;riaktag=\"contains\",
&lt;/riak/cages/1&gt;;riaktag=\"next_to\"" \
-d '{"room" : 101}'
</code></pre>

<p>Now you can retrieve all the links from cage 1.</p>

<pre><code>$ curl http://localhost:8098/riak/cages/1/_,_,_
--4PYi9DW8iJK5aCvQQrrP7mh7jZs
Content-Type: multipart/mixed; boundary=Av1fawIA4WjypRlz5gHJtrRqklD
--Av1fawIA4WjypRlz5gHJtrRqklD
X-Riak-Vclock: a85hYGBgzGDKBVIcypz/fvrde/U5gymRMY+VwZw35gRfFgA=
Location: /riak/animals/polly
Content-Type: application/json
Link: &lt;/riak/animals&gt;; rel="up"
Etag: VD0ZAfOTsIHsgG5PM3YZW
Last-Modified: Tue, 13 Dec 2011 17:53:59 GMT
{"nickname" : "Sweet Polly Purebred", "breed" : "Purebred"}
--Av1fawIA4WjypRlz5gHJtrRqklD--
--4PYi9DW8iJK5aCvQQrrP7mh7jZs--
</code></pre>

<p>This is a bit of a mess, and we'll find an easier way to walk these links soon. But you could walk along these with cURL.</p>

<p>You can also store metadata by using the X-Riak-Meta header prefix.</p>

<p>There are a lot of MIME types in Riak including, but not limited to image/jpeg, etc.</p>

<h3>
<a id="mapreduce-and-server-clusters" class="anchor" href="#mapreduce-and-server-clusters" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Mapreduce and server clusters</h3>

<p>Mapreduce allows us to perform more powerful queries than standard key-value paradigm.</p>

<p>The popularization is in part thanks to Google. Mapreduce has two parts:
1. Convert a list of data into another type of list by way of a map() function
2. Convert the second list to one or more scalar values by way of reduce</p>

<p>Following this pattern allows you run them across a massive cluster of servers in parallel. For example, we could count up all Riak values by mapping each matching document to 1 and then reducing the sum of all these counts.</p>

<pre><code>map = function(v) {
var parsedData = JSON.parse(v.values[0].data);
if(parsedData.country === 'CA')
return [{count : 1}];
else
return [{count : 0}];
}
reduce = function(mappedVals) {
var sums = {count : 0};
for (var i in mappedVals) {
sums[count] += mappedVals[i][count];
}
return [sums];
}
</code></pre>

<p>This is opposite to how we used to run the select statement. Rather than grabbing data from the database and running it on a client, mapreduce is a pattern to pass an algorithm to all of the database nodes (IMPORTANT!).</p>

<p>See figure 7 for a map reduce function example. Works great when we have a lot of data and don't want to move all of it from the server to the client.</p>

<p>See Reducer Patterns on page 70.</p>

<h3>
<a id="consistency-and-durability" class="anchor" href="#consistency-and-durability" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Consistency and Durability</h3>

<p>Riak server architecture removes single points of failures</p>

<p>It is not possible to create
a distributed database that is fully consistent, available, and partition tolerant.
You can have only two (partition tolerant and consistent, partition tolerant
and available, or consistent and available but not distributed). This is known
as the CAP theorem (Consistency, Availability, Partition tolerance). </p>

<h1>
<a id="hbase" class="anchor" href="#hbase" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>HBase</h1>

<ul>
<li>Made for big jobs (multiple gigabytes or more)</li>
<li>At a glance looks like a relational database because of similar terms, but this is not the case</li>
<li>Hbase is the bizzaro RBDMS</li>
</ul>

<h3>
<a id="why-use-hbase" class="anchor" href="#why-use-hbase" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Why use HBase?</h3>

<ul>
<li>Versioning</li>
<li>Compression</li>
<li>Garbage Collection for expired data</li>
<li>In-memory tables</li>
<li>Strong consistency guarantees</li>
<li>For big queries HBase can outperform other DBs</li>
<li>Often used for logging or large search database</li>
</ul>

<h3>
<a id="some-details" class="anchor" href="#some-details" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Some details</h3>

<ul>
<li>Initially made for natural language processing database</li>
<li>Based off Google's Big Table paper</li>
<li>Column-oriented</li>
<li>HBase is fault tolerent</li>
<li>HBase is built on Hadoop</li>
<li>Actively developed</li>
<li>Used by big companies (Facebook, Yahoo!, Twitter, etc)</li>
</ul>

<h3>
<a id="hbase-shell" class="anchor" href="#hbase-shell" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>HBase Shell</h3>

<pre><code>${HBASE_HOME}/bin/hbase shell
</code></pre>

<h3>
<a id="creating-a-table" class="anchor" href="#creating-a-table" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Creating a table</h3>

<ul>
<li>A table in HBase is a map of maps</li>
<li>Keys are arbitrary strings that map to a row of data</li>
<li>The row itself is a map in which keys are called columns and values are uninterpreted bytes</li>
<li>Columns are grouped into column families often the family and column name are grouped together with a colon</li>
<li>See Figure 13 on page 98</li>
</ul>

<h4>
<a id="creating-a-table-and-adding-data-wiki-example" class="anchor" href="#creating-a-table-and-adding-data-wiki-example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Creating a table and adding data wiki example</h4>

<p>See Figure 14 on page 99</p>

<p>Creating the table</p>

<pre><code>hbase&gt; create 'wiki', 'text'
</code></pre>

<p>Table is currently empty. It has no rows. One column family called text.</p>

<p>Inserting data into the table</p>

<pre><code>hbase&gt; put 'wiki', 'Home', 'text:', 'Welcome to the wiki!'
</code></pre>

<p>You can query the db</p>

<pre><code>hbase&gt; get 'wiki', 'Home', 'text:'
</code></pre>

<p>This returns something like</p>

<pre><code>COLUMN CELL
text: timestamp=1295774833226, value=Welcome to the wiki!
1 row(s) in 0.0590 seconds
</code></pre>

<p>Notice the timestamp. HBase keeps track of historical data for you automatically, so you get versioning built right in.</p>

<h4>
<a id="cool-aside" class="anchor" href="#cool-aside" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Cool aside</h4>

<p>Facebook using HBase tables for its messaging index table</p>

<ul>
<li>HBase allows you to override the timestamp field on both get and put operations adding another dimension that you can overload. This is what Facebook did.</li>
</ul>

<h4>
<a id="a-more-complete-and-complicated-wiki-example" class="anchor" href="#a-more-complete-and-complicated-wiki-example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A more complete and complicated Wiki Example</h4>

<p>See Figure 15 and Figure 16 on page 102</p>

<p>To make changes to the schema, first disable the table</p>

<pre><code>hbase&gt; disable 'wiki'
</code></pre>

<p>Then we can modify column family characteristics using</p>

<pre><code>hbase&gt; alter 'wiki', { NAME =&gt; 'text', VERSIONS =&gt;
hbase* org.apache.hadoop.hbase.HConstants::ALL_VERSIONS }
</code></pre>

<p>Note: Operations that alter column family characteristics can be very expensive
because HBase has to create a new column family with the chosen specifications
and then copy all the data over. In a production system, this may incur
significant downtime. For this reason, settling on column family options up
front is a good thing.</p>

<p>For our next example, let's add a new column family called revision</p>

<pre><code>hbase&gt; alter 'wiki', { NAME =&gt; 'revision', VERSIONS =&gt;
hbase* org.apache.hadoop.hbase.HConstants::ALL_VERSIONS }
</code></pre>

<p>Some more important notes:</p>

<ul>
<li>we’re only adding a revision column family to the table schema, not individual columns. </li>
<li>we expect each row to eventually contain a revision:author and revision:comment</li>
<li>But it’s up to the client to honor this expectation</li>
<li>Not enforced by a schema</li>
<li>HBase will not stop you from doing bad things like adding in a new column</li>
</ul>

<p>Once you are done, you will want to enable the table</p>

<pre><code>hbase&gt; enable 'wiki'
</code></pre>
      </section>
      <footer>
        <p>Project maintained by <a href="https://github.com/Anderson-Lab">Anderson-Lab</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
