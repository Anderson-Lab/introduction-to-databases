<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Introduction to Databases by Anderson-Lab</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/main.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>

      <header>
        <h1>Introduction to Databases</h1>
        <p>Comparative Database Technologies</p>
      </header>

      <div id="banner">
        <span id="logo"></span>

        <a href="https://github.com/Anderson-Lab/introduction-to-databases" class="button fork"><strong>View On GitHub</strong></a>
        <div class="downloads">
          <span>Downloads:</span>
          <ul>
            <li><a href="https://github.com/Anderson-Lab/introduction-to-databases/zipball/master" class="button">ZIP</a></li>
            <li><a href="https://github.com/Anderson-Lab/introduction-to-databases/tarball/master" class="button">TAR</a></li>
          </ul>
        </div>
      </div><!-- end banner -->

    <div class="wrapper">
      <nav>
        <ul></ul>
      </nav>
      <section>
        <h1>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h1>

<p>It is often said that data is the new oil. If this is the case, then the database is how we store, collect, organize, and basically do everything with the oil until it goes into your car.</p>

<p>For a long time, relational databases were the only game in town. It is not the case anymore. There are now a variety of options, schemaless, horizontal scaling, high availability, etc. These are generally known as NoSQL databases. On this page, we will attempt to compare different databases, and more importantly try to answer the all important question:</p>

<p>What database or combination of databases best resolves your problem?</p>

<p>To answer this, we need to learn a little more.</p>

<p>What type of datastore is this?</p>

<ul>
<li>Relational (e.g., postgres)</li>
<li>Key-value (e.g., Riak, Redis)</li>
<li>Columnar (e.g., HBase)</li>
<li>Document-oriented (e.g., MongoDB, CouchDB)</li>
<li>Graph (e.g., Neo4J)</li>
</ul>

<p>Databases are created for a purpose. So we need to understand their purpose to pick.</p>

<p>How do you talk to it?</p>

<p>How does it perform?</p>

<p>How does it scale?</p>

<p>Important to remember: Most of your problems can be solved by multiple databases, so it is a matter of finding the best for the situation.</p>

<h3>
<a id="relational-databases" class="anchor" href="#relational-databases" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Relational Databases</h3>

<ul>
<li>Traditional</li>
<li>Relational Database Management Systems (RDBMSs) are set-theory-based.</li>
<li>Tables with rows and columns.</li>
<li>Write queries in Structured Query Language (SQL)</li>
<li>Data types are numeric, strings, dates, blobs, etc</li>
<li>Based on mathematical relational (set) theory</li>
</ul>

<h3>
<a id="key-value" class="anchor" href="#key-value" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Key-Value</h3>

<ul>
<li>Pairs keys to values in much the same way as a map (or hastable)</li>
<li>Very simple and great performance</li>
<li>No complex query and aggregation needs</li>
</ul>

<h3>
<a id="columnar" class="anchor" href="#columnar" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Columnar</h3>

<ul>
<li>Data from a given column (in the two-dimensional table sense) is stored together.</li>
<li>By contrast, a row-oriented database (like an RDBMS) keeps information about a row together.</li>
<li>Adding columns is quite inexpensive and is done on a row-by-row basis.</li>
<li>Each row can have a different set of columns, or none at all, allowing tables to remain sparse without incurring a storage cost for null values. </li>
<li>Columnar is about midway between relational and key-value. </li>
</ul>

<h3>
<a id="document-oriented-databases-store-well-documents" class="anchor" href="#document-oriented-databases-store-well-documents" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Document-oriented databases store, well, documents</h3>

<ul>
<li>A document is like a hash</li>
<li>Documents can contain nested structures</li>
<li>Exhibit a high degree of flexibility, allowing for variable domains. </li>
</ul>

<h3>
<a id="graph-databases" class="anchor" href="#graph-databases" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Graph Databases</h3>

<ul>
<li>Less commonly used database styles</li>
<li>Good at dealing with highly interconnected data. </li>
<li>A graph database consists of nodes and relationships between nodes. </li>
<li>Strength of graph databases is traversing through the nodes by following relationships. </li>
</ul>

<h1>
<a id="postgresql" class="anchor" href="#postgresql" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>PostgreSQL</h1>

<ul>
<li>Common</li>
<li>Old and trusty tool</li>
<li>Solves a number of problems</li>
<li>We can't move on to fancy new databases until we understand this</li>
<li>Battle-tested</li>
<li>It’s fast and reliable</li>
<li>Can handle terabytes of data</li>
<li>Has been proven to run in high-profile production</li>
<li>Companies using it: Skype, France’s Caisse Nationale d’Allocations Familiales (CNAF), and the United States’ Federal Aviation Administration (FAA). </li>
</ul>

<h3>
<a id="getting-started" class="anchor" href="#getting-started" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Getting Started</h3>

<p>Create the book schema</p>

<pre><code>$ createdb book
</code></pre>

<p>Run your first query</p>

<pre><code>psql book -c "SELECT '1'::cube;" 
</code></pre>

<h3>
<a id="relations-crud-and-joins" class="anchor" href="#relations-crud-and-joins" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Relations, CRUD, and Joins</h3>

<p>Postgres provides a back-end server that does all of the work and a command-line shell to connect to the running. It's a good thing we are good at this!</p>

<p>Connect to the database and the schema book</p>

<pre><code>psql book
</code></pre>

<ul>
<li>Typing \h lists information about SQL commands</li>
<li>Follows the SQL convention of calling relations TABLEs</li>
<li>Attributes are COLUMNs</li>
<li>Tuples are ROWs.</li>
<li>You may encounter the mathematical terms relations, attributes, and tuples. </li>
</ul>

<p>PostgreSQL is a design-first datastore. Design the schema first. Then enter data. Here is how you create a table:</p>

<pre><code>CREATE TABLE countries ( country_code char(2) PRIMARY KEY, country_name text UNIQUE );
</code></pre>

<p>See mathematical relations in book for foundations of relational database</p>

<p>Once we have a table, we can insert it into it</p>

<pre><code>INSERT INTO countries (country_code, country_name) 
VALUES ('us','United States'), ('mx','Mexico'), ('au','Australia'), ('gb','United Kingdom'), ('de','Germany'), ('ll','Loompaland'); 
</code></pre>

<p>What if you try to insert a duplicate?</p>

<pre><code>INSERT INTO countries VALUES ('uk','United Kingdom');
ERROR: duplicate key value violates unique constraint "countries_country_name_key" DETAIL: Key (country_name)=(United Kingdom) already exists.
</code></pre>

<p>How can we get data back out?</p>

<pre><code>SELECT * FROM countries;
country_code | country_name 
--------------+--------------
us | United States 
mx | Mexico 
au | Australia 
gb | United Kingdom 
de | Germany 
ll | Loompaland 
(6 rows)
</code></pre>

<p>How to remove from the database?</p>

<pre><code>DELETE FROM countries WHERE country_code = 'll'; 
</code></pre>

<p>CRUD: Create, Read, Update, and Delete.</p>

<ul>
<li>Inserting new records (creating)</li>
<li>Reading existing records (reading)</li>
<li>Modifying existing records (updating)</li>
<li>Removing records you no longer need (deleting)</li>
</ul>

<p>It gets more complex</p>

<pre><code>CREATE TABLE cities ( 
  name text NOT NULL, 
  postal_code varchar(9) CHECK (postal_code &lt;&gt; ''), 
  country_code char(2) REFERENCES countries, 
  PRIMARY KEY (country_code, postal_code) ); 
</code></pre>

<ul>
<li>Constrained the name in cities by disallowing NULL values. </li>
<li>Constrained postal_code by checking that no values are empty strings (&lt;&gt; means not equal). </li>
<li>PRIMARYKEY uniquely identifies a row - created a compound key: country_code + postal_code.</li>
</ul>

<p><b>Foreign keys and referential integrity</b></p>

<pre><code>INSERT INTO cities VALUES ('Toronto','M4C1B5','ca');
ERROR: insert or update on table "cities" violates foreign key constraint "cities_country_code_fkey" DETAIL: Key (country_code)=(ca) is not present in table "countries".
</code></pre>

<ul>
<li>country_code REFERENCES countries</li>
<li>the country_code must exist in the countries table. </li>
<li>Called maintaining referential integrity.</li>
</ul>

<p>See Figure 1.</p>

<h3>
<a id="join-reads" class="anchor" href="#join-reads" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Join Reads</h3>

<ul>
<li>Most other databases also perform CRUD operations.</li>
<li>What sets relational databases like PostgreSQL apart is their ability to join tables together when reading them. </li>
<li>Joining is an operation taking two separate tables and combining them in some way to return a single table. </li>
<li>In the simplest form, you specify two columns (one from each table) to match by, using the ON keyword. </li>
</ul>

<pre><code>SELECT cities.*, country_name FROM cities INNER JOIN countries ON cities.country_code = countries.country_code;
country_code | name | postal_code | country_name 
--------------+----------+-------------+--------------
us | Portland | 97205 | United States 
</code></pre>

<p>Outer joins</p>

<ul>
<li>Merging two tables when the results of one table must always be returned, whether or not any matching column values exist on the other table. </li>
</ul>

<pre><code>SELECT e.title, v.name FROM events e LEFT JOIN venues v ON e.venue_id = v.venue_id;
</code></pre>

<p>Example of left join:</p>

<pre><code>SELECT e.title, v.name
FROM events e LEFT JOIN venues v
ON e.venue_id = v.venue_id;
title            | name
-----------------+----------------
LARP Club        | Voodoo Donuts
April Fools Day  |
Christmas Day    |
</code></pre>

<h3>
<a id="erd" class="anchor" href="#erd" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ERD</h3>

<p>See sample ERD in Figure 2</p>

<h3>
<a id="indexes-and-b-trees" class="anchor" href="#indexes-and-b-trees" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Indexes and B-trees</h3>

<p>Consider the statement:</p>

<pre><code>SELECT * FROM events WHERE event_id = 2;
</code></pre>

<p>How many records does PostgreSQL have to look through?</p>

<p>An index is a special data structure built to avoid a full table scan when performing a query. Without an index you have to check every row for a match. For indices, we use a B-tree data structure. See Figure 3.</p>

<p>Here is a good summary of concepts. <b>Term Definition</b></p>

<ul>
<li>Column - A domain of values of a certain type, sometimes called an attribute</li>
<li>Row - An object comprised as a set of column values, sometimes called
a tuple</li>
<li>Table A set of rows with the same columns, sometimes called a relation</li>
<li>Primary key - The unique value that pinpoints a specific row</li>
<li>CRUD - Create, Read, Update, Delete</li>
<li>SQL - Structured Query Language, the lingua franca of a relational database</li>
<li>Join Combining two tables into one by some matching columns</li>
<li>Left join - Combining two tables into one by some matching columns or NULL if nothing matches the left table </li>
<li>Index - A data structure to optimize selection of a specific set of columns</li>
<li>B-tree - A good standard index; values are stored as a balanced tree
data structure; very flexible</li>
</ul>

<h4>
<a id="aggregate-functions" class="anchor" href="#aggregate-functions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Aggregate Functions</h4>

<pre><code>title            | starts              |           ends      | venue
-----------------+---------------------+---------------------+---------------
Wedding          | 2012-02-26 21:00:00 | 2012-02-26 23:00:00 | Voodoo Donuts
Dinner with Mom  | 2012-02-26 18:00:00 | 2012-02-26 20:30:00 | My Place
Valentine’s Day  | 2012-02-14 00:00:00 | 2012-02-14 23:59:00 |
</code></pre>

<p>Consider the following statements, where % is a wildcard:</p>

<pre><code>SELECT count(title)
FROM events
WHERE title LIKE '%Day%';
</code></pre>

<pre><code>SELECT min(starts), max(ends)
FROM events INNER JOIN venues
ON events.venue_id = venues.venue_id
WHERE venues.name = 'Crystal Ballroom';
</code></pre>

<p>These are great, but limited on their own. Consider what if we wanted to count by vendor ID:</p>

<pre><code>SELECT count(*) FROM events WHERE venue_id = 1;
SELECT count(*) FROM events WHERE venue_id = 2;
SELECT count(*) FROM events WHERE venue_id = 3;
SELECT count(*) FROM events WHERE venue_id IS NULL;
</code></pre>

<p>This is pretty annoying. What we really need is a group by statement!</p>

<pre><code>SELECT venue_id FROM events GROUP BY venue_id;
</code></pre>
      </section>
      <footer>
        <p>Project maintained by <a href="https://github.com/Anderson-Lab">Anderson-Lab</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
